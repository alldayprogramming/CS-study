### 해시

> 임의의 길이의 데이터를 고정된 길이의 값으로 매핑한 값. 해시 함수에 의해 매핑됨
> 
- 키(Key): 매핑 전 원래 데이터
- 해시, 해시값(hash value): 매핑 후 고정된 길이의 값
- 해싱(hashing): 매핑하는 과정
    
    ![스크린샷 2025-11-16 오후 9.15.55.png](%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94%20%EA%B5%AC%ED%98%84/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-11-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.15.55.png)
    
    매핑된 해시값은 배열의 인덱스로 사용됨
    

### 해시 테이블

> 키와 값 쌍을 저장하는 자료 구조로, 키를 해시 함수를 통해 해시 값으로 변환한 후에 해당 해시 값을 기반으로 배열 형태의 저장 공간에 저장함
> 

**해시 충돌**

> 어떤 키가 이미 있는 상태에서 다른 키가 삽입을 시도하는 것
> 

→ 해결방법: 체이닝, 개방 주소

- 체이닝
    - 같은 주소로 해싱되는 키를 하나의 연결 리스트에 연결하여 관리
- 개방 주소
    - 추가 공간을 사용하지 않고 충돌하게 된다면 다음 주소를 탐색하여 빈 공간에 저장
    - 선형 탐색, 이차원 탐색, 더블 해싱의 방법으로 다음 주소를 탐색함
    
    <aside>
    
    **선형 탐색**
    
    다음 자리부터 탐색해 빈곳에 삽입
    
    **이차원 탐색**
    
    다음 자리부터 탐색하는 대신 보폭을 이차 함수에 의해 넓히면서 탐색(군집 영역을 벗어나기 위함)
    
    **더블 해싱**
    
    2개의 해시를 사용하여 충돌 발생 시 두번 째 해시 함숫값만큼 이동(2차 군집문제를 피하기 위함)
    
    </aside>
    

### 코드

```java
package CodeForces;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Solution {
	
	static final int HASH_SIZE = 1000;
	static final int HASH_LEN = 400;
	static final int HASH_VAL = 17; // 소수로 할 것
	
	static int[][] data = new int[HASH_SIZE][HASH_LEN];
	static int[] length = new int[HASH_SIZE];
	static String[][] s_data = new String[HASH_SIZE][HASH_LEN];
	static String str;
	static int N;

	public static void main(String[] args) throws Exception {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		N = Integer.parseInt(br.readLine()); // 입력 수 (1~100000)
		
		for (int i = 0; i < N; i++) {
			
			str = br.readLine();
			
			int key = getHashKey(str);
			int cnt = checking(key);
			
			if(cnt != -1) { // 이미 들어왔던 문자열
				sb.append(str).append(cnt).append("\n");
			}
			else sb.append("OK").append("\n");
		}
		
		System.out.println(sb.toString());
	}
	
	public static int getHashKey(String str) {
		
		int key = 0;
		
		for (int i = 0; i < str.length(); i++) {
			key = (key * HASH_VAL) + str.charAt(i) + HASH_VAL;
		}
		
		if(key < 0) key = -key; // 만약 key 값이 음수면 양수로 바꿔주기
		
		return key % HASH_SIZE;
		
	}
	
	public static int checking(int key) {
		
		int len = length[key]; // 현재 key에 담긴 수 (같은 key 값으로 들어오는 문자열이 있을 수 있다)
		
		if(len != 0) { // 이미 들어온 적 있음
			
			for (int i = 0; i < len; i++) { // 이미 들어온 문자열이 해당 key 배열에 있는지 확인
				if(str.equals(s_data[key][i])) {
					data[key][i]++;
					return data[key][i];
				}
			}
			
		}
		
		// 들어온 적이 없었으면 해당 key배열에서 문자열을 저장하고 길이 1 늘리기
		s_data[key][length[key]++] = str;

		return -1; // 처음으로 들어가는 경우 -1 리턴
	}

}
```
